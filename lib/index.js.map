{"version":3,"file":"index.js","sources":["../src/lib/AccessControlProvider.svelte","../src/lib/ComponentAccessControl.svelte","../src/lib/RouteAccessControl.svelte","../src/lib/MenuAccessControl.svelte","../src/lib/DropdownAccessControl.svelte"],"sourcesContent":["<script lang=\"ts\">\n    /**\n     * AccessControlProvider\n     *\n     * Provides role/group-based access control context to its children.\n     * This component registers provided `roles` and `groups`, tracks the current\n     * account's role and optional group via the `account` store, and exposes\n     * the following Svelte contexts to descendants:\n     *\n     * - `AccessControl`: The initialized access control instance\n     * - `CurrentAccessRole`: Writable<Role | null> representing the active role\n     * - `CurrentAccessRoleGroup`: Writable<Group | null> representing the active group (if any)\n     *\n     * Usage:\n     * ```svelte\n     * <AccessControlProvider {roles} {groups} account={user}>\n     *   <!-- children that consume contexts -->\n     * </AccessControlProvider>\n     * ```\n     */\n    import { setContext, type Snippet, onDestroy } from \"svelte\";\n    import { writable, type Readable } from \"svelte/store\";\n    import { createAccessControl, type Group, type Role, type RolePermissions } from \"permit-core\";\n\n    type Roles = Role[];\n    type RoleCodes = Array<Roles[number]['code']>;\n    type Groups = Group[];\n    type GroupCodes = Array<Groups[number]['code']>;\n\n    /**\n     * Component props\n     *\n     * @prop {Snippet} children - Subtree rendered inside the provider. Receives contexts via Svelte's getContext.\n     * @prop {Roles} roles - List of registered roles for the access control system.\n     * @prop {Groups} groups - List of registered groups. May include inheritance.\n     * @prop {Readable<{ role: string; groupFlag?: string } | null>} account - Reactive account state. When `role` or `groupFlag` changes, contexts update accordingly. When `null`, contexts reset.\n     */\n    const { children, roles, groups, account }: { \n        children: Snippet, \n        roles: Roles, \n        groups: Groups,\n        account: Readable<(Record<string, any> & { role: string; groupFlag?: string }) | null>\n    } = $props();\n\n    /** Initialized access control instance bound to provided roles */\n    const accessControl = createAccessControl({ roles });\n    /** Writable store for the active role */\n    const currentRole = writable<Role | null>(null);\n    /** Writable store for the active group (if any) */\n    const currentRoleGroup = writable<Group | null>(null);\n    /** Cached current group code to detect changes */\n    let currentGroupCode = $state<GroupCodes[number] | null>(null);\n    /** Cached current role code to detect changes */\n    let currentRoleCode = $state<RoleCodes[number] | null>(null);\n\n    groups.forEach(group => accessControl.addGroup(group));\n    roles.forEach(role => accessControl.addRole(role));\n\n    /**\n     * Subscribes to external `account` store.\n     *\n     * - When `state.role` changes, updates the active role.\n     * - When `state.groupFlag` is present and matches a known group, assigns the group to the active role.\n     * - When `state` is `null`, resets role and group contexts.\n     */\n    const unsubscribe = account.subscribe((state) => {\n        if (state && state.role !== currentRoleCode) {\n            currentRoleCode = state.role;\n            $currentRole = accessControl.getRoleByCode(currentRoleCode);\n\n            if (!currentRole) {\n                throw new Error('role is not registered in the access control module');\n            }\n        }\n\n        if (!state) {\n            $currentRole = null;\n            $currentRoleGroup = null;\n            currentRoleCode = null;\n            currentGroupCode = null;\n        }\n\n        if (state?.groupFlag && currentRole) {\n            const group = accessControl.getGroupByCode(state.groupFlag);\n            if (group) {\n                $currentRole.resetGroup();\n                $currentRole.assignGroup(group);\n                $currentRoleGroup = group;\n                currentGroupCode = group.getCode();\n            } else {\n                $currentRole.resetGroup();\n                $currentRoleGroup = null;\n                currentGroupCode = null;\n            }\n        }\n    });\n\n    /** Cleans up the `account` subscription when the provider is destroyed. */\n    onDestroy(unsubscribe);\n\n    /** Expose access control instance to descendants */\n    setContext('AccessControl', accessControl);\n    /** Expose active role store to descendants */\n    setContext('CurrentAccessRole', currentRole);\n    /** Expose active group store to descendants */\n    setContext('CurrentAccessRoleGroup', currentRoleGroup);\n</script>\n\n{@render children()}","<script lang=\"ts\">\n    /**\n     * ComponentAccessControl\n     *\n     * Guards a UI fragment (children snippet) behind component-level permissions\n     * driven by the active role (and optionally its group) from the access control context.\n     * If the current role has `view` permission for the provided `identifier`, the `children`\n     * snippet is rendered with `{ isEditable, role }`. If not, the optional `fallback` snippet\n     * is rendered instead.\n     *\n     * Contexts consumed:\n     * - `AccessControl`: Access control instance to evaluate actions\n     * - `CurrentAccessRole`: Writable<Role | null>\n     * - `CurrentAccessRoleGroup`: Writable<Group | null>\n     *\n     * Usage:\n     * ```svelte\n     * <ComponentAccessControl identifier=\"admin-panel\">\n     *   {#snippet children({ isEditable, role })}\n     *     <button disabled={!isEditable}>Edit</button>\n     *   {/snippet}\n     *   {#snippet fallback({ role })}\n     *     <p>Access denied</p>\n     *   {/snippet}\n     * </ComponentAccessControl>\n     * ```\n     */\n    import { ComponentAccessAction, type AccessControl, type RolePermissionGroup, type Role, type Group} from \"permit-core\";\n\timport { getContext, type Snippet } from 'svelte';\n\timport type { Writable } from 'svelte/store';\n\n\t/**\n\t * Component props\n\t *\n\t * @prop {string} identifier - Unique component identifier to check access against.\n\t * @prop {Snippet<[{ isEditable: boolean; role: Role }]>} children - Rendered when `view` is allowed. Receives editability and active role.\n\t * @prop {Snippet<[{ role: Role }]>} [fallback] - Rendered when `view` is denied. Receives the active role.\n\t */\n\tconst { identifier, children, fallback }: { \n\t\tidentifier: string; \n\t\tchildren: Snippet<[{ isEditable: boolean; role: Role }]>, \n\t\tfallback?: Snippet<[{ role: Role }]> \n\t} = $props();\n\n\t/** Access control instance provided by the nearest AccessControlProvider */\n\tconst accessControl = getContext<AccessControl>('AccessControl');\n\t/** Currently active role (reactive store) */\n\tconst currentRole = getContext<Writable<Role>>(\"CurrentAccessRole\");\n\t/** Currently active group assigned to the role, if any (reactive store) */\n\tconst currentRoleGroup = getContext<Writable<Group>>(\"CurrentAccessRoleGroup\");\n\n\t/** Whether the component is visible (has `view` permission) */\n\tlet isVisible = $state(false);\n\t/** Whether the component is editable (has `edit` permission) */\n\tlet isEditable = $state(false);\n\t/** Cached values to detect when to re-evaluate permissions */\n\tlet currentRoleCode = $state<string>();\n\tlet currentRoleGroupCode = $state<string | undefined>();\n\tlet currentRolePermissions = $state([]);\n\n\t/** Re-evaluates visibility and editability when role/group/permissions change */\n\t$effect(() => {\n\t\tif (\n\t\t\t$currentRole && \n\t\t\t($currentRole.getCode() !== currentRoleCode\n\t\t\t|| $currentRoleGroup?.getCode() !== currentRoleGroupCode\n\t\t\t|| $currentRole.getPermissions().length !== currentRolePermissions.length)\n\t\t) {\n\t\t\tcurrentRoleCode = $currentRole.getCode();\n\t\t\tcurrentRoleGroupCode = $currentRoleGroup?.getCode();\n\t\t\tcurrentRolePermissions = $currentRole.getPermissions();\n\t\t\tconst componentViewAction = new ComponentAccessAction(currentRoleCode, {\n\t\t\t\tidentifier: identifier,\n\t\t\t\taction: 'view'\n\t\t\t});\n\n\t\t\taccessControl.checkPermissions<ComponentAccessAction>(componentViewAction, {\n\t\t\t\tonSuccess: (action) => {\n\t\t\t\t\tisVisible = true;\n\t\t\t\t},\n\t\t\t\tonFailure: (action) => {\n\t\t\t\t\tisVisible = false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst componentEditAction = new ComponentAccessAction(currentRoleCode, {\n\t\t\t\tidentifier: identifier,\n\t\t\t\taction: 'edit'\n\t\t\t});\n\n\t\t\taccessControl.checkPermissions<ComponentAccessAction>(componentEditAction, {\n\t\t\t\tonSuccess: (action) => {\n\t\t\t\t\tisEditable = true;\n\t\t\t\t},\n\t\t\t\tonFailure: (action) => {\n\t\t\t\t\tisEditable = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n{#if isVisible}\n    {@render children({isEditable, role: $currentRole})}\n{:else if fallback}\n    {@render fallback({role: $currentRole})}\n{/if}\n","<script lang=\"ts\">\n    /**\n     * RouteAccessControl\n     *\n     * Evaluates whether the active role (and optionally its group) has access to a given `route`.\n     * Renders the `children` snippet when access is granted; otherwise renders the `fallback` snippet.\n     *\n     * Consumed contexts:\n     * - `AccessControl`: Access control instance\n     * - `CurrentAccessRole`: Writable<Role | null>\n     * - `CurrentAccessRoleGroup`: Writable<Group | null>\n     *\n     * Usage:\n     * ```svelte\n     * <RouteAccessControl route=\"/admin\">\n     *   {#snippet children({ role, route })}\n     *     <p>Access granted to {route}</p>\n     *   {/snippet}\n     *   {#snippet fallback({ role, route })}\n     *     <p>Access denied to {route}</p>\n     *   {/snippet}\n     * </RouteAccessControl>\n     * ```\n     */\n    import { createRouteAccessAction, type AccessControl, type Role, Permission, type Group, RouteAccessAction } from \"permit-core\";\n    import type { Writable } from \"svelte/store\";\n    import { getContext, type Snippet } from \"svelte\";\n\n    /**\n     * Component props\n     *\n     * @prop {string} route - Route path to check access against.\n     * @prop {Snippet<[{ role: Writable<Role>; route: string }]>} children - Rendered when access is granted.\n     * @prop {Snippet<[{ role: Writable<Role>; route: string }]>} fallback - Rendered when access is denied.\n     */\n    const { route, children, fallback }: { route: string; children: Snippet<[{ role: Writable<Role>; route: string }]>; fallback: Snippet<[{ role: Writable<Role>; route: string }]> } = $props();\n\n    /** Access control instance provided by AccessControlProvider */\n    const accessControl = getContext<AccessControl>('AccessControl');\n    /** Active role store */\n    const currentRole = getContext<Writable<Role>>(\"CurrentAccessRole\");\n    /** Active group store (if assigned) */\n    const currentRoleGroup = getContext<Writable<Group>>(\"CurrentAccessRoleGroup\");\n\n    /** Whether the `route` is accessible for the current role */\n    let isAccessible = $state<boolean>(false);\n    /** Cached values to detect when to re-evaluate */\n    let currentRoleCode = $state<string>();\n    let currentRoleGroupCode = $state<string | undefined>();\n    let currentRolePermissions = $state([]);\n\n    /** Re-evaluate route access when role/group/permissions change */\n    $effect(() => {\n        if (\n            $currentRole && \n            ($currentRole.getCode() !== currentRoleCode \n            || $currentRoleGroup?.getCode() !== currentRoleGroupCode\n            || $currentRole.getPermissions().length !== currentRolePermissions.length)\n        ) {\n            currentRoleCode = $currentRole.getCode();\n            currentRoleGroupCode = $currentRoleGroup?.getCode();\n            currentRolePermissions = $currentRole.getPermissions();\n\n            const routeAccessAction = createRouteAccessAction(currentRoleCode, {\n                route\n            });\n\n            accessControl.checkPermissions<RouteAccessAction>(routeAccessAction, {\n                onSuccess: () => {\n                    isAccessible = true\n                },\n                onFailure: () => {\n                    isAccessible = false;\n                }\n            });\n        }\n    });\n</script>\n\n{#if isAccessible}\n    {@render children({ role: currentRole, route })}\n{:else}\n    {@render fallback({ role: currentRole, route })}\n{/if}","<script lang=\"ts\">\n\t/**\n\t * MenuAccessControl\n\t *\n\t * Computes the list of accessible menu items for the active role (and optional group)\n\t * using the access control context, and renders the `children` snippet for each item\n\t * in `menuList`, indicating whether the item is editable/visible for that role.\n\t *\n\t * Consumed contexts:\n\t * - `AccessControl`: Access control instance\n\t * - `CurrentAccessRole`: Writable<Role | null>\n\t * - `CurrentAccessRoleGroup`: Writable<Group | null>\n\t *\n\t * Usage:\n\t * ```svelte\n\t * <ul>\n\t * \t\t<MenuAccessControl identifier=\"menu-items\" menuList={menuItems}>\n\t *   \t\t{#snippet children({ menu, isEditable })}\n\t *     \t\t\t<li class={classNames({\n\t *       \t\t\t'hidden': !isEditable\n\t *     \t\t\t})}>{menu}</li>\n\t *   \t\t{/snippet}\n\t * \t\t</MenuAccessControl>\n\t * </ul>\n\t * ```\n\t */\n\timport { MenuAccessAction, type AccessControl, type Role, type Group, MenuAccessPermission } from 'permit-core';\n\timport type { Writable } from 'svelte/store';   \n\timport { getContext, type Snippet } from 'svelte';\n\n\ttype T = $$Generic;\n\n\t/**\n\t * Component props\n\t *\n\t * @prop {Array<T>} menuList - Full list of candidate menu items to evaluate.\n\t * @prop {string} identifier - Menu permission identifier to check against.\n\t * @prop {Snippet<[{ isEditable: boolean; role: Writable<Role>; menu: T; index: number }]>} children - Rendered for each item, with editability flag.\n\t */\n\tconst { menuList, identifier, children }: { menuList: Array<T>, identifier: string, children: Snippet<[{ isEditable: boolean; role: Writable<Role>; menu: T; index: number }]> } = $props();\n\n\t/** Access control instance provided by AccessControlProvider */\n\tconst accessControl = getContext<AccessControl>('AccessControl');\n\t/** Active role store */\n\tconst currentRole = getContext<Writable<Role>>(\"CurrentAccessRole\");\n\t/** Active group store (if assigned) */\n\tconst currentRoleGroup = getContext<Writable<Group>>(\"CurrentAccessRoleGroup\");\n\n\t/** Computed accessible menu list for the current role */\n\tlet accessibleMenu = $state<Array<T>>([]);\n\t/** Cached values to detect when to recompute */\n\tlet currentRoleCode = $state<string>();\n\tlet currentRoleGroupCode = $state<string | undefined>();\n\tlet currentRolePermissions = $state([]);\n\n\t/** Recompute accessible menu when role/group/permissions change */\n\t$effect(() => {\n\t\tif (\n\t\t\t$currentRole && \n\t\t\t($currentRole.getCode() !== currentRoleCode \n\t\t\t|| $currentRoleGroup?.getCode() !== currentRoleGroupCode\n\t\t\t|| $currentRole.getPermissions().length !== currentRolePermissions.length)\n\t\t) {\n\t\t\tcurrentRoleCode = $currentRole.getCode();\n\t\t\tcurrentRoleGroupCode = $currentRoleGroup?.getCode();\n\t\t\tcurrentRolePermissions = $currentRole.getPermissions();\n\n\t\t\tconst menuAccessAction = new MenuAccessAction(currentRoleCode, {\n\t\t\t\tidentifier,\n\t\t\t\tmenu: menuList as string[]\n\t\t\t});\n\n\t\t\taccessControl.checkPermissions<MenuAccessAction>(menuAccessAction, {\n\t\t\t\tonSuccess: (action) => {\n\t\t\t\t\tconst menuAccessPermission = $currentRole.getPermissions<MenuAccessPermission>(\"menu\")[0];\n\t\t\t\t\taccessibleMenu = menuAccessPermission.getAccessibleList(action) as Array<T>;\n\t\t\t\t},\n\t\t\t\tonFailure: () => {\n\t\t\t\t\taccessibleMenu = [];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n{#each menuList as menu, index}\n    {@render children({ isEditable: accessibleMenu.includes(menu), role: currentRole, menu, index })}\n{/each}\n","<script lang=\"ts\">\n    /**\n     * DropdownAccessControl\n     *\n     * Computes the list of accessible dropdown items for the active role (and optional group)\n     * using the access control context, and renders the `children` snippet for each item\n     * in `list`, indicating whether the item is editable/visible for that role.\n     *\n     * Consumed contexts:\n     * - `AccessControl`: Access control instance\n     * - `CurrentAccessRole`: Writable<Role | null>\n     * - `CurrentAccessRoleGroup`: Writable<Group | null>\n     *\n     * Usage (following DropdownDemo):\n     * ```svelte\n     * <ul class=\"space-y-2\">\n     *   <DropdownAccessControl identifier={DEMO_DATA.dropdown.identifier} list={items}>\n     *     {#snippet children({ isEditable, item })}\n     *       <li class=\"flex items-center\">\n     *         <div class={classNames('w-3 h-3 rounded-full mr-2', {\n     *           'bg-green-500': isEditable,\n     *           'bg-red-500': !isEditable,\n     *         })}></div>\n     *         <span>{DEMO_DATA.dropdown.items.find(i => i.id === item)?.name}</span>\n     *       </li>\n     *     {/snippet}\n     *   </DropdownAccessControl>\n     * </ul>\n     * ```\n     */\n\timport { createDropdownAccessAction, type AccessControl, type Role, type Group, createDropdownPermission } from 'permit-core';\n\timport type { Writable } from 'svelte/store';\n\timport { getContext, type Snippet } from 'svelte';\n\n\ttype T = $$Generic;\n\t\n\t/**\n\t * Component props\n\t *\n\t * @prop {Array<T>} list - Full list of candidate dropdown items to evaluate.\n\t * @prop {string} identifier - Dropdown permission identifier to check against.\n\t * @prop {Snippet<[{ isEditable: boolean; role: Writable<Role>; item: T; index: number }]>} children - Rendered for each item, with editability flag.\n\t */\n\tconst { list, identifier, children }: { list: Array<T>, identifier: string, children: Snippet<[{ isEditable: boolean; role: Writable<Role>; item: T; index: number }]> } = $props();\n\n\t/** Access control instance provided by AccessControlProvider */\n\tconst accessControl = getContext<AccessControl>('AccessControl');\n\t/** Active role store */\n\tconst currentRole = getContext<Writable<Role>>(\"CurrentAccessRole\");\n\t/** Active group store (if assigned) */\n\tconst currentRoleGroup = getContext<Writable<Group>>(\"CurrentAccessRoleGroup\");\n\n\t/** Cached values to detect when to recompute */\n\tlet currentRoleCode = $state<string>();\n\tlet currentRoleGroupCode = $state<string | undefined>();\n\tlet currentRolePermissions = $state([]);\n\t/** Computed accessible items for the current role */\n\tlet accessibleItems = $state<Array<T>>([]);\n\n\t/** Recompute accessible dropdown items when role/group/permissions change */\n\t$effect(() => {\n\t\tif (\n\t\t\t$currentRole && \n\t\t\t($currentRole.getCode() !== currentRoleCode\n\t\t\t|| $currentRoleGroup?.getCode() !== currentRoleGroupCode\n\t\t\t|| $currentRole.getPermissions().length !== currentRolePermissions.length)\n\t\t) {\n\t\t\tcurrentRoleCode = $currentRole.getCode();\n\t\t\tcurrentRoleGroupCode = $currentRoleGroup?.getCode();\n\t\t\tcurrentRolePermissions = $currentRole.getPermissions();\n\n\t\t\tconst dropdownAccessAction = createDropdownAccessAction(currentRoleCode, {\n\t\t\t\tidentifier,\n\t\t\t\tdropdown: list as string[]\n\t\t\t});\n\n\t\t\taccessControl.checkPermissions<ReturnType<typeof createDropdownAccessAction>>(dropdownAccessAction, {\n\t\t\t\tonSuccess: (action) => {\n\t\t\t\t\tconst dropdownAccessPermission = $currentRole.getPermissions<ReturnType<typeof createDropdownPermission>>(\"dropdown\")[0];\n\t\t\t\t\taccessibleItems = dropdownAccessPermission.getAccessibleList(action) as Array<T>;\n\t\t\t\t},\n\t\t\t\tonFailure: () => {\n\t\t\t\t\taccessibleItems = [];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n{#each list as item, index}\n    {@render children({ isEditable: accessibleItems.includes(item), role: currentRole, item, index })}\n{/each}\n"],"names":["$","node_1","$$props","isEditable","$currentRole","node_2","isVisible","$$render","consequent","alternate","currentRole","isAccessible","menu","index","accessibleMenu","item","accessibleItems"],"mappings":";;;;;;iBAAA;;;;;;;;;;;;;;;;AA0GA;iBC1GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGuB,MAAAA,EAAA,QAAAC,GAAA,MAAAC,EAAA,UAAA,OAAA,EAAA,YAAUF,EAAA,IAAVG,CAAU,GAAE,MAAMC,EAAY,EAAA,EAAA;;;;;AAE9B,UAAAJ,EAAA,QAAAK,GAAA,MAAAH,EAAA,UAAA,OAAA,EAAA,MAAME,EAAY,EAAA,EAAA;;;;;;;;;;;;YAHpCE,CAAS,IAAAC,EAAAC,CAAA,IAAAD,EAAAE,GAAA,EAAA;AAAA;;;AAFd;iBCpGA;;;;;;;;;;;;;;;;;;;;;;;8CAgFwB,MAAMC,GAAa,OAAKR,EAAA,MAAA,EAAA;;;8CAExB,MAAMQ,GAAa,OAAKR,EAAA,MAAA,EAAA;;;YAH3CS,CAAY,IAAAJ,EAAAC,CAAA,IAAAD,EAAAE,GAAA,EAAA;AAAA;;;AAFjB;iBC7EA;;;;;;;;;;;;;;;;;;;;;+CAqFmBG,GAAIC,MAAA;;MACC,YAAUb,EAAA,IAAEc,CAAc,EAAC,eAASF,CAAI,CAAA;AAAA,MAAG,MAAMF;AAAA,MAAa,YAAAE,CAAI;AAAA,MAAE,OAAAC;AAAA;;;AAH5F;iBCnFA;;;;;;;;;;;;;;;;;;;;;2CAyFeE,GAAIF,MAAA;;MACK,YAAUb,EAAA,IAAEgB,CAAe,EAAC,eAASD,CAAI,CAAA;AAAA,MAAG,MAAML;AAAA,MAAa,YAAAK,CAAI;AAAA,MAAE,OAAAF;AAAA;;;AAH7F;"}